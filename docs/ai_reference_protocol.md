# AI报告参考协议 v1.0

> 确保AI在规划和参考时使用正确版本的报告

## 核心原则

**铁律**: AI在参考历史报告时，必须使用 `bash scripts/find_best_reference.sh` 确定最佳版本

## 自动化查找规则

### 1. 脚本调用

**必须调用场景**:
- Phase 0开始前参考类似公司报告
- 框架规划时需要参考最佳实践
- 用户询问某公司历史分析时

**调用方法**:
```bash
# 自动推荐最佳版本
bash scripts/find_best_reference.sh TICKER

# 用户指定特定文件
bash scripts/find_best_reference.sh TICKER "reports/TICKER/specific_file.md"
```

### 2. 版本优先级（自动）

```
1. 最新版本号 (v3.1 > v3.0 > v2.0)
2. 相同版本选择最大文件
3. main分支优于worktree
4. Complete文件优于其他类型
```

### 3. 质量验证

脚本自动检查：
- ✅ **≥250K**: Tier 3标准
- ⚠️ **<250K**: 需要注意质量限制
- ❌ **不存在**: 无有效参考

## AI操作指令

### Phase 0参考流程

```yaml
步骤1: 确定参考标的
  - 同行业公司优先 (半导体→AMD/TSM, 消费→COST等)
  - 相似复杂度公司 (高期权→TSLA/PLTR, 传统→TSM/LRCX)

步骤2: 脚本查找最佳版本
  - 执行: bash scripts/find_best_reference.sh {参考公司}
  - 记录推荐文件路径和质量指标

步骤3: 读取关键部分
  - 框架结构 (目录)
  - Phase 0可能性宽度评估
  - 方法论选择逻辑
  - KS/TS设计模式

步骤4: 适配当前公司
  - 借鉴结构不照抄内容
  - 根据新公司特点调整方法
```

### 用户指定文件处理

```yaml
明确指定:
  - 用户说"参考PLTR v3.1"→直接使用v3.1
  - 用户提供完整路径→验证存在后使用

模糊指定:
  - 用户说"参考最好的PLTR"→脚本自动查找
  - 用户说"参考类似公司"→AI判断+脚本查找
```

## 质量分级参考

| 级别 | 大小范围 | 推荐参考内容 |
|------|----------|--------------|
| **优秀** | ≥400K | 全面参考：结构+方法+执行细节 |
| **良好** | 250K-400K | 主要参考：结构+关键方法论 |
| **基础** | 150K-250K | 有限参考：仅参考结构框架 |
| **不推荐** | <150K | 避免参考：可能不完整 |

## 错误示例避免

❌ **禁止做法**:
- 随意选择版本："我看看PLTR的报告"→直接读取搜到的第一个
- 忽略质量标志："这个200K的报告应该够了"
- 参考staging文件："staging/文件看起来很新"

✅ **正确做法**:
- 脚本确认版本："让我确认PLTR的最佳版本"→运行脚本
- 质量验证："推荐文件593.6K，符合标准"
- 明确声明参考："基于PLTR v3.1 (593.6K, ✅Tier 3标准)的框架设计..."

## 记录格式

在Phase 0中记录参考信息：
```markdown
## 参考基准
- **选定报告**: {TICKER}_Complete_v{X.Y}_{DATE}.md
- **文件大小**: {SIZE}K
- **质量等级**: {优秀/良好/基础}
- **参考原因**: {同行业/相似复杂度/框架标杆/等}
- **借鉴要点**: {结构/方法/执行细节}
```

## 脚本维护

- 路径: `scripts/find_best_reference.sh`
- 权限: 可执行 (`chmod +x`)
- 依赖: bash, bc (macOS兼容)
- 更新: 随框架升级同步更新版本号逻辑